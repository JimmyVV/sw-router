'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var EventEmitter = _interopDefault(require('events'));
var path = require('path');
var path__default = path['default'];
var module$1 = _interopDefault(require('module'));
var fs = require('fs');

var path$1 = path__default;
var Module = module$1;

var modules = {};

var getModule = function(dir) {
  var rootPath = dir ? path$1.resolve(dir) : process.cwd();
  var rootName = path$1.join(rootPath, '@root');
  var root = modules[rootName];
  if (!root) {
    root = new Module(rootName);
    root.filename = rootName;
    root.paths = Module._nodeModulePaths(rootPath);
    modules[rootName] = root;
  }
  return root;
};

var requireRelative = function(requested, relativeTo) {
  var root = getModule(relativeTo);
  return root.require(requested);
};

requireRelative.resolve = function(requested, relativeTo) {
  var root = getModule(relativeTo);
  return Module._resolveFilename(requested, root);
};

var index$1 = requireRelative;

function sequence ( array, fn ) {
	let results = [];
	let promise = Promise.resolve();

	function next ( member, i ) {
		return fn( member ).then( value => results[i] = value );
	}

	for ( let i = 0; i < array.length; i += 1 ) {
		promise = promise.then( () => next( array[i], i ) );
	}

	return promise.then( () => results );
}

const opts = { encoding: 'utf-8', persistent: true };

let chokidar;

try {
	chokidar = index$1( 'chokidar', process.cwd() );
} catch (err) {
	chokidar = null;
}

class FileWatcher {
	constructor ( file, data, callback, dispose ) {
		const handleWatchEvent = event => {
			if ( event === 'rename' || event === 'unlink' ) {
				this.fsWatcher.close();
				dispose();
				callback();
			} else {
				// this is necessary because we get duplicate events...
				const contents = fs.readFileSync( file, 'utf-8' );
				if ( contents !== data ) {
					data = contents;
					callback();
				}
			}
		};

		try {
			if (chokidar)
				{ this.fsWatcher = chokidar.watch(file, { ignoreInitial: true }).on('all', handleWatchEvent); }
			else
				{ this.fsWatcher = fs.watch( file, opts, handleWatchEvent); }

			this.fileExists = true;
		} catch ( err ) {
			if ( err.code === 'ENOENT' ) {
				// can't watch files that don't exist (e.g. injected
				// by plugins somehow)
				this.fileExists = false;
			} else {
				throw err;
			}
		}
	}

	close () {
		this.fsWatcher.close();
	}
}

function watch$1 ( rollup, options ) {
	const watcher = new EventEmitter();

	const dests = options.dest ? [ path.resolve( options.dest ) ] : options.targets.map( target => path.resolve( target.dest ) );
	let filewatchers = new Map();

	let rebuildScheduled = false;
	let building = false;
	let watching = false;
	let closed = false;

	let timeout;
	let cache;

	function triggerRebuild () {
		clearTimeout( timeout );
		rebuildScheduled = true;

		timeout = setTimeout( () => {
			if ( !building ) { build(); }
		}, 50 );
	}

	function build () {
		if ( building || closed ) { return; }

		rebuildScheduled = false;

		let start = Date.now();
		let initial = !watching;
		if ( cache ) { options.cache = cache; }

		watcher.emit( 'event', { code: 'BUILD_START' });

		building = true;

		return rollup.rollup( options )
			.then( bundle => {
				// Save off bundle for re-use later
				cache = bundle;

				if ( !closed ) {
					bundle.modules.forEach( module => {
						let id = module.id;

						// skip plugin helper modules
						if ( /\0/.test( id ) ) { return; }

						try {
							id = fs.realpathSync( id );
						} catch ( err ) {
							return;
						}

						if ( ~dests.indexOf( id ) ) {
							throw new Error( 'Cannot import the generated bundle' );
						}

						if ( !filewatchers.has( id ) ) {
							const watcher = new FileWatcher( id, module.originalCode, triggerRebuild, () => {
								filewatchers.delete( id );
							});

							if ( watcher.fileExists ) { filewatchers.set( id, watcher ); }
						}
					});
				}

				// Now we're watching
				watching = true;

				if ( options.targets ) {
					return sequence( options.targets, target => {
						const mergedOptions = Object.assign( {}, options, target );
						return bundle.write( mergedOptions );
					});
				}

				return bundle.write( options );
			})
			.then( () => {
				watcher.emit( 'event', {
					code: 'BUILD_END',
					duration: Date.now() - start,
					initial
				});
			}, error => {
				watcher.emit( 'event', {
					code: 'ERROR',
					error
				});
			})
			.then( () => {
				building = false;
				if ( rebuildScheduled && !closed ) { build(); }
			});
	}

	// build on next tick, so consumers can listen for BUILD_START
	process.nextTick( build );

	watcher.close = () => {
		for ( const fw of filewatchers.values() ) {
			fw.close();
		}
		closed = true;
	};

	return watcher;
}

module.exports = watch$1;
